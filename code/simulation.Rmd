---
title: "MoD Simulation in R"
author: "Jiho Yeo & Sujin Lee"
date: '2020 9 29 '
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data Description 

#### Import data (Taxi data in Daejeon)

```{r cars}
# Passenger drop on, off data in Daejeon
passen_final<-read_csv("data/passen_final.csv")

# Median travel time between zones
TravelTime<-read_csv("data/TravelTime.csv")

# All passenger pick-up/drop-off in 3 months
### For derive standard deviation of demand
passen_all<-read_csv("data/passen_all.csv")

# Speed over zones by time
speed_by_zone <- read.csv("data/speed_by_zone_time.csv")

# 42 Grids
ROI<-sort(c(61, 105, 136, 146, 154, 168, 184, 189, 190, 191, 194, 196, 199, 206, 225, 229, 230, 231, 233, 240, 241,
       245, 246, 251, 253, 257, 258, 260, 266, 268, 318, 320, 375, 391, 395, 400, 424, 442, 459, 464, 465, 468))

# Grid coordinate
grid<-passen_final %>% select(dprt_grid,dprt_grid_x,dprt_grid_y) %>% filter(dprt_grid %in% ROI) %>% distinct()
```

#### Change Coordination

- 위경도 좌표를 직각좌표계로 변환 (격자 Centroid)

```{r}
grid.sp <- SpatialPoints(grid %>% select(-dprt_grid),CRS("+init=epsg:4326")) # 위경도 좌표계 
grid.sp <-  spTransform(grid.sp, CRS("+init=epsg:5181")) # 중부원점 좌표계로 변환
grid_xy <- data.frame(grid.sp)

grid_xy$dprt_grid_x <-  grid_xy$dprt_grid_x  -min(grid_xy$dprt_grid_x )
grid_xy$dprt_grid_y <-  grid_xy$dprt_grid_y  -min(grid_xy$dprt_grid_y )
grid_xy$dprt_grid_x <- trunc(grid_xy$dprt_grid_x/100)*100
grid_xy$dprt_grid_y <- trunc(grid_xy$dprt_grid_y/100)*100

colnames(grid_xy) <- c("X_centroid","Y_centroid")
grid<-cbind(grid,grid_xy)

grid<-grid %>% arrange(X_centroid,Y_centroid)
grid$X_centroid<-grid$X_centroid + 500
grid$Y_centroid<-grid$Y_centroid + 500

plot(grid$X,grid$Y)
rm(grid_xy); rm(grid.sp);
```

#### Set parameters

```{r}
# Time index; 30 minutes intervals
Time<-ymd_hms("2017-03-02 00:00:00")+hours(0:23)
Time<-c(Time,Time + minutes(30)) %>% sort()

# Length of grid (1km)
L<-1

# Road density by zones
Rho<-road_length$LengthSum # Road density by grids

N<-42 # Number of grids
M<-5
Phi <-vector("list",48) # Call demand density of zones #Phi
Xi <-vector("list",48) # Street demand density of zones #Xi 
k<-0.1 # Ratio between Street and Call demand
Psi<-vector("list",48) # Arrival rate of zones 

Eta<-vector("list",48) # Maximum discharge rate at hubs 

A <- vector("list",48) # Density of vacant vehicles at zones
B <- vector("list",48) # Density of vacant vehicles at stations
v <- vector("list",48) # Vehicle speed
Epsilon <- vector("list",48) # Travel time between zones

# Vehicle Speed
# 일단 15km/h로 고정
VehicleSpeed <- 15*1000/60 # meters/min
```

## Passenger Generator
- 승객의 30분 단위의 O-D matrix 및 Uncertainty (Standard Deviation)에 따라 임의의 승객 O-D pairs를 생성
- Input: O-D matrix by 30 minutes interval
- Output: Randomly Generated O-D pairs over time (24 hours)
- Assumtion: O-D is uniformly generated in spatial-temporal area

#### Make O-D matrix in 30min-interval
```{r}
# Make 30 minutes interval
passen_final$dprt_time_30min <- floor_date(passen_final$dprt_time,"30 minutes")
passen_final$arrvl_time_30min <- floor_date(passen_final$arrvl_time,"30 minutes")

passen_final_ROI <-   passen_final %>% 
  filter(dprt_grid %in% ROI, arrvl_grid %in% ROI) %>%
  arrange(dprt_time_30min)
```

#### Passenger O-D Generator
- `passen_final_ROI`을 기반으로 randomly distributed 되게 승하차 좌표와 호출시간을 매핑
```{r pressure, echo=FALSE}
PassengerGenerator <- function (passen_final_ROI) {
  OD_Pairs_tmp<-passen_final_ROI %>% 
  select(dprt_grid,arrvl_grid,dprt_time,dprt_time_30min) %>%
  arrange(dprt_time) %>% 
  left_join(grid, by="dprt_grid") %>% 
  select(X_start=X_centroid,Y_start=Y_centroid, dprt_grid, arrvl_grid, dprt_time, dprt_time_30min) %>%
  left_join(grid %>% select(dprt_grid,X_end=X_centroid,Y_end=Y_centroid), by=c("arrvl_grid"="dprt_grid")) %>%
  select(dprt_time,dprt_time_30min,X_start,Y_start,X_end,Y_end,dprt_grid,arrvl_grid)

  OD_Pairs_tmp$X_start<-OD_Pairs_tmp$X_start + runif(nrow(OD_Pairs_tmp), min=-500, max=500)
  OD_Pairs_tmp$Y_start<-OD_Pairs_tmp$Y_start + runif(nrow(OD_Pairs_tmp), min=-500, max=500)
  OD_Pairs_tmp$X_end<-OD_Pairs_tmp$X_end + runif(nrow(OD_Pairs_tmp), min=-500, max=500)
  OD_Pairs_tmp$Y_end<-OD_Pairs_tmp$Y_end + runif(nrow(OD_Pairs_tmp), min=-500, max=500)
  OD_Pairs_tmp$PassengerID <- 1:nrow(OD_Pairs_tmp)
  
  # 시간 변수를 numeric으로 변경
  OD_Pairs_tmp$time <- as.numeric(OD_Pairs_tmp$dprt_time)-1488412800
  OD_Pairs_tmp$time<-trunc(OD_Pairs_tmp$time/60)+1
  OD_Pairs_tmp$VehicleID<-NA
  OD_Pairs_tmp$wait_time <- 0
  
  return(OD_Pairs_tmp)
}
```

- `PassengerGenerator`를 통한 OD_pairs 생성
```{r}
OD_Pairs_tmp <- PassengerGenerator(passen_final_ROI)

  
# Dataframe을 시간대별 List 형식으로 변경
OD_Pairs <- vector("list",1440)

for(i in 1:1440) {
 OD_Pairs[[i]]<-OD_Pairs_tmp %>% filter(time==i)
}

```

- 시간대별 간단한 수요 및 공급 시각화
  - 수요 
```{r}
demand<-OD_Pairs_tmp %>% group_by(dprt_time_30min) %>% summarise(demand=n())
plot(demand$dprt_time_30min,demand$demand)
```

  - 공급
```{r}
supply<-passen_final %>% filter(dprt_grid %in% ROI, arrvl_grid %in% ROI) %>% select(carnum, dprt_time_30min) %>%
  group_by(dprt_time_30min) %>% summarise(n=length(unique(carnum)))

plot(supply$dprt_time_30min, supply$n)
```

## Dispacher (Idle >> Assign)
- 승객이 생성되었을 때, 빈차와 승객을 매칭시켜주는 알고리즘
- 기본적으로 Greedy하게 가장 가까운 승객과 차를 순차적으로 매칭시키도록 함

#### Set Vehicle status 
- 시간대별로 Vehicle의 상태에 따라 list를 생성
- Idle; In-operation; Assign; In-relocation 상태가 존재함

```{r}
InitialVehicle <- data.frame(VehicleID=1:700)
InitialVehicle$X <- runif(nrow(InitialVehicle), min=0, max=7000)
InitialVehicle$Y <- runif(nrow(InitialVehicle), min=0, max=6000)
InitialVehicle$state<-"idle" # state consists of c("idle","assign,"operate","in-relo")
InitialVehicle$time<-1
```


```{r}
IdleVehicle <- vector("list",1440)
```

```{r}
OprtVehicle <- vector("list",1440)
```

```{r}
AssignVehicle <- vector("list",1440)
```

```{r}
ReloVehicle <- vector("list",1440)
```

#### Vehicle Dispacher
- 빈차를 승객과 매칭시킴
- 승객이 호출하는 순서대로 가장 가까이 위치한 차량을 매칭시킴
- Idle >> Assign 상태로 변하는 차량들을 컨트롤

```{r pressure, echo=FALSE}
Dispacher <- function (OD_Pairs, IdleVehicle, time) {
  
  # Passenger OD-pair at time t
  OD_tmp<-OD_Pairs[[time]]
  if (nrow(OD_tmp)==0) {
    IdleVehicle[[time+1]] <<- IdleVehicle[[time]]
  } else {
    # Idle vehicle at time t
    if (time==1) Idle_tmp<-InitialVehicle else Idle_tmp<- IdleVehicle[[time]]
    
    # Match passenger & vehicle (Shortest path)
    # State change (idle >> assign)
    for (i in 1:min(nrow(OD_tmp),nrow(Idle_tmp))){
      
    # Greed search
    Idle_tmp2 <- Idle_tmp %>% filter(state == "idle")
    passenger_vehicle_match <- which.min(abs(Idle_tmp2$X-OD_tmp[i,]$X_start)+abs(Idle_tmp2$Y-OD_tmp[i,]$Y_start))
    assign_vehicle_id <- Idle_tmp2$VehicleID[passenger_vehicle_match]
    OD_tmp$VehicleID[i]<-assign_vehicle_id
    
    # Update Idle vehicle
    Idle_tmp[Idle_tmp$VehicleID==assign_vehicle_id,]$state<-"assign"
    }
    
    # Update Idle & Assigned vehicle
    Assign_tmp <- Idle_tmp %>% filter(state=="assign")
    Idle_tmp <- Idle_tmp %>% filter(state=="idle")
    rm(Idle_tmp2)
    
    # Join the information of passenger trip (start & end location of trip & grid_id)
    Assign_tmp <- Assign_tmp %>% 
      left_join(OD_tmp %>% select(VehicleID,X_start,Y_start,X_end,Y_end,dprt_grid,arrvl_grid), by="VehicleID")
    
    Idle_tmp <- Idle_tmp %>% filter(state=="idle")
    
    # Update passenger demands
    OD_Pairs[[time]]<<-OD_tmp[!is.na(OD_tmp$VehicleID),]
    
    # Update unassigned passenger to next timestamp
    unassigned_demand <- OD_tmp[is.na(OD_tmp$VehicleID),]
    unassigned_demand$wait_time <- unassigned_demand$wait_time+1
    OD_Pairs[[time+1]]<<-rbind(unassigned_demand, OD_Pairs[[time+1]])
    
    # Update Idle & Assign vehicle
    IdleVehicle[[time]]<<- Idle_tmp
    if (time!=1440) IdleVehicle[[time+1]]<<- Idle_tmp else print("Simulation Finish!")
    if (time==1) AssignVehicle[[time]] <<- Assign_tmp else AssignVehicle[[time]]<<- rbind(AssignVehicle[[time]],Assign_tmp)
  }
}

```

#### Vehicle Position Updater 
- 현재위치, 목적지를 알 때 Vehicle의 위치를 time stamp마다 update 시킴

```{r}
VehiclePositionUpdater <- function (x_start,y_start,x_end,y_end, VehicleSpeed){
  travel_distance <- VehicleSpeed
  x_gap <- x_end - x_start
  y_gap <- y_end - y_start
  
  if (abs(x_gap)+abs(y_gap)>travel_distance){
    
    if (abs(x_gap) > travel_distance) {
      x_update <- x_start + x_gap*(travel_distance/abs(x_gap))
      y_update<-y_start
    } else {
        x_update <- x_end
        travel_distance <- travel_distance - abs(x_gap)
        y_update <- y_start + y_gap*(travel_distance/abs(y_gap))
        }
    } else {
        x_update <- x_end
        y_update <- y_end
      }
  
  position_update <- c(x_update,y_update)
  return(position_update)
}
```


#### Update Vehicle state in assigning(Assign >> Operation)
- Assign 된 차량들의 위치를 time stamp마다 계속 업데이트
- 승객의 위치까지 도달하면 vehicle state를 assign 에서 operation으로 변경

```{r}
Assign_to_Oprt <- function (AssignVehicle, time) {
  # Passenger OD-pair at time t
  Assign_tmp<-AssignVehicle[[time]]
  
  position_update<-mapply(VehiclePositionUpdater,Assign_tmp$X,Assign_tmp$Y,Assign_tmp$X_start,Assign_tmp$Y_start,VehicleSpeed)
  Assign_tmp$X<-position_update[1,]
  Assign_tmp$Y<-position_update[2,]
  
  Assign_tmp$state<-ifelse(Assign_tmp$X==Assign_tmp$X_start & Assign_tmp$Y == Assign_tmp$Y_start,"operate","assign")
  
  AssignVehicle[[time+1]]<<- Assign_tmp %>% filter(state=="assign")
  OprtVehicle[[time+1]]<<- Assign_tmp %>% filter(state=="operate")
}

Assign_to_Oprt(AssignVehicle,time=1)
AssignVehicle[[2]]
OprtVehicle[[2]]
```


#### Update Vehicle state in operation (Operation >> Idle)
- In-operation 중인 차량들의 위치를 time stamp마다 계속 업데이트
- 승객의 목적지까지 도달하면 vehicle state를 operation에서 idle로 변경

```{r}
Oprt_to_Idle <- function (OprtVehicle, time) {
  if (time==1) print("There is no vehicles in operation") else {
    Oprt_tmp<-OprtVehicle[[time]]
    position_update<-mapply(VehiclePositionUpdater,Oprt_tmp$X,Oprt_tmp$Y,Oprt_tmp$X_end,Oprt_tmp$Y_end,VehicleSpeed)
    Oprt_tmp$X<-position_update[1,]
    Oprt_tmp$Y<-position_update[2,]
    
    Oprt_tmp$state<-ifelse(Oprt_tmp$X==Oprt_tmp$X_end & Oprt_tmp$Y == Oprt_tmp$Y_end,"idle","operate")
    
    OprtVehicle[[time+1]]<<- rbind(OprtVehicle[[time+1]], Oprt_tmp %>% filter(state=="operate"))
    IdleVehicle[[time+1]]<<- rbind(IdleVehicle[[time+1]], Oprt_tmp %>% filter(state=="idle") %>% select(colnames(IdleVehicle[[time]]))) 
  }
}


```


## Run simulation without Relocation
- Repositioning 알고리즘이 적용되지 않았을 때의 Simulation 구동

```{r}
for (i in 1:1439){
  Dispacher(OD_Pairs, IdleVehicle, time=i)
  Assign_to_Oprt(AssignVehicle,time=i)
  Oprt_to_Idle(OprtVehicle,time=i)
}

# Modify time factor

for (i in 2:1440){
  if (nrow(IdleVehicle[[i]])!=0) IdleVehicle[[i]]$time <- i
  if (nrow(AssignVehicle[[i]])!=0) AssignVehicle[[i]]$time <- i
  if (nrow(OprtVehicle[[i]])!=0) OprtVehicle[[i]]$time <- i
}

NumIdleVehicle <- sapply(1:1440,function(k) nrow(IdleVehicle[[k]]))
plot(NumIdleVehicle, ylim=c(0,700))
```

#### Visualization Vehicles & Passengers 

```{r}
library(viridis)
library(plotly)
library(RColorBrewer)

agg_IdleVehicle <- do.call(rbind,sapply(1:1440, function (k) IdleVehicle[[k]], simplify = FALSE))
agg_IdleVehicle<-agg_IdleVehicle %>% select(VehicleID,X,Y,state,time)

agg_AssignVehicle <- do.call(rbind,sapply(1:1440, function (k) AssignVehicle[[k]], simplify = FALSE))
agg_AssignVehicle<-agg_AssignVehicle %>% select(VehicleID,X,Y,state,time)

agg_OprtVehicle <- do.call(rbind,sapply(1:1440, function (k) OprtVehicle[[k]], simplify = FALSE))
agg_OprtVehicle<-agg_OprtVehicle %>% select(VehicleID,X,Y,state,time)



agg_vis_dat <- rbind(agg_IdleVehicle, agg_AssignVehicle, agg_OprtVehicle)
agg_vis_dat <- rbind(agg_vis_dat, data.frame(VehicleID=999,X=0,Y=0,state="operate",time=1))
tmp <- agg_vis_dat %>% filter(time %in% 1200:1300)



pl <- tmp %>%
  plot_ly(
    x = ~X, 
    y = ~Y, 
    # size = ~pop, 
    # color = ~state, 
    # frame = ~time, 
    text = ~paste('</br> VehicleID: ', VehicleID,
                      '</br> State: ', state), 
    hoverinfo = "text"
  ) %>%
  add_markers(color = ~factor(state),
              colors = c(viridis(10)[2],viridis(10)[5],viridis(10)[10]),
              frame = ~time) %>%
  animation_opts(frame=1,transition = 0, easing = "linear", redraw = FALSE)

pl
```

#### Save simulation result for visualization

```{r}
save(agg_vis_dat, file = "dashboard/vis_dat.RData")
```


## Inter-zonal Repositioner (GA)
- 매 30분마다, 각 존에서 다른 존으로 vehicle을 이동시킴
- 만약 보내야하는 차량의 수가 현재 존의 차량의 수보다 작다면 오는 순서대로 다른 존으로 보냄


## Intra-zonal Repositioner (Hueristic)
- real-time으로 존안에 남아있는 차량들의 위치를 control 함
- Strategy 1과 Strategy 2에 대해서 각각 따로 모듈을 만들 필요가 있음

#### Strategy 1 (Equally distributed condition)

#### Strategy 2 (Spot-based static condition)
- Sujin taks
- Zone에 1000m by 1000m 
- Pods이 x개가 있을 때
- X pods들의 X,y 좌표가 리턴되는 함수
```{r}
library(amap)
library(sqldf)

intra_pod <- function(k) {
  x= as.data.frame(seq(from = 0, to = 1000, by = 1))
  y= as.data.frame(seq(from = 0, to = 1000, by = 1))

  p<-sqldf("SELECT x, y from x, y")
  temp <- Kmeans(p, k, method = "manhattan")
  pod<-as.data.frame(temp$center)

  return(pod)
}
```

## Cost Calculator
- 시뮬레이션이 작동함에 따라 total cost가 계산되도록 하는 모듈


## Get Parameter
- 시뮬레이션이 작동됨에 따라 변하는 parameter들을 기록


## Run Simulation with Relocation






